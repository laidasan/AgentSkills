# Plan-Validate-Execute

## 適用條件（When to Use）

- 操作不可逆或影響範圍大（刪除、覆寫、批次修改）
- 批次操作，一次處理多個對象
- 執行成本高，失敗後重來代價大
- 需要在執行前讓使用者或腳本確認計畫

## 概念說明

先產出中間計畫檔（結構化、可機器驗證）→ 用腳本或規則驗證計畫 → 確認無誤後才執行。核心價值是把「決策」和「執行」分離，錯誤在計畫階段就被攔截。

## 範例

以「批次檔案重命名 Skill」為例，workflow 可設計為：

````markdown
## 批次重命名流程

**Step 1: 掃描目標檔案**

讀取指定目錄下的所有檔案清單。

→ 輸入：目錄路徑 + 篩選條件
→ 輸出：檔案清單

**Step 2: 產生重命名計畫**

根據命名規則，產出 `rename-plan.json`：

```json
[
  { "from": "IMG_001.jpg", "to": "2024-01-15_photo_001.jpg" },
  { "from": "IMG_002.jpg", "to": "2024-01-15_photo_002.jpg" }
]
```

→ 輸入：檔案清單 + 命名規則
→ 輸出：rename-plan.json

**Step 3: 驗證計畫**

檢查 rename-plan.json：
- 目標檔名無重複
- 目標檔名符合命名規則
- 所有來源檔案都存在
- 無覆寫風險（目標檔名不與現有檔案衝突）

若驗證失敗 → 回到 Step 2 修正計畫。

**Step 4: 確認後執行**

驗證通過後，依計畫逐一執行重命名。

→ 輸入：rename-plan.json
→ 輸出：重命名完成的檔案
````

### 設計重點

- 中間計畫檔必須是結構化格式（JSON、YAML），方便腳本驗證
- 驗證腳本的錯誤訊息要具體：「目標檔名 X 與現有檔案 Y 衝突」，不是只說「有衝突」
- 計畫檔本身就是可審閱的產物，使用者可以在執行前人工檢查
- 與 Feedback Loop 的差異：Feedback Loop 是「做了再驗」，這裡是「驗了才做」
